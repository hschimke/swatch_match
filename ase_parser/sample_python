# encoding: utf-8
"""
swatch, a parser for adobe swatch exchange files
Copyright (c) 2014 Marcos A Ojeda http://generic.cx/

With notes from
http://iamacamera.org/default.aspx?id=109 by Carl Camera and
http://www.colourlovers.com/ase.phps by Chris Williams

All Rights Reserved
MIT Licensed, see LICENSE.TXT for details
"""


__title__ = 'swatch'
__version__ = '0.4.0'
__author__ = 'Marcos Ojeda'
__license__ = 'MIT'
__copyright__ = 'Copyright 2014 Marcos A Ojeda'


import struct


def parse(filename):
  """parses a .ase file and returns a list of colors and color groups

  `swatch.parse` reads in an ase file and converts it to a list of colors and
  palettes. colors are simple dicts of the form

  ```json
  {
    'name': u'color name',
    'type': u'Process',
    'data': {
      'mode': u'RGB',
      'values': [1.0, 1.0, 1.0]
    }
  }
  ```

  the values provided vary between color mode. For all color modes, the
  value is always a list of floats.

  RGB: three floats between [0,1] corresponding to RGB.
  CMYK: four floats between [0,1] inclusive, corresponding to CMYK.
  Gray: one float between [0,1] with 1 being white, 0 being black.
  LAB: three floats. The first L, is ranged from 0,1. Both A and B are
  floats ranging from [-128.0,127.0]. I believe illustrator just crops
  these to whole values, though.

  Palettes (née Color Groups in Adobe Parlance) are also dicts, but they have an
  attribute named `swatches` which contains a list of colors contained within
  the palette.

  ```json
  {
    'name': u'accent colors',
    'type': u'Color Group',
    'swatches': [
      {color}, {color}, ..., {color}
    ]
  }
  ```

  Because Adobe Illustrator lets swatches exist either inside and outside
  of palettes, the output of swatch.parse is a list that may contain
  swatches and palettes, i.e. [ swatch* palette* ]

  Here's an example with a light grey swatch followed by a color group containing three

    >>> import swatch
    >>> swatch.parse("example.ase")
    [{'data': {'mode': u'Gray', 'values': [0.75]},
     'name': u'Light Grey',
     'type': u'Process'},
     {'name': u'Accent Colors',
     'swatches': [{'data': {'mode': u'CMYK',
       'values': [0.5279774069786072,
       0.24386966228485107,
       1.0,
       0.04303044080734253]},
      'name': u'Green',
      'type': u'Process'},
      {'data': {'mode': u'CMYK',
       'values': [0.6261844635009766,
       0.5890134572982788,
       3.051804378628731e-05,
       3.051804378628731e-05]},
      'name': u'Violet Process Global',
      'type': u'Global'},
      {'data': {'mode': u'LAB', 'values': [0.6000000238418579, -35.0, -5.0]},
      'name': u'Cyan Spot (global)',
      'type': u'Spot'}],
     'type': u'Color Group'}]
  """

  with open(filename, "rb") as data:
    header, v_major, v_minor, chunk_count = struct.unpack("!4sHHI", data.read(12))

    assert header == b"ASEF"
    assert (v_major, v_minor) == (1, 0)

    return [c for c in parser.parse_chunk(data)]

def dumps(obj):
  """converts a swatch to bytes suitable for writing"""
  header = b'ASEF'
  v_major, v_minor = 1, 0
  chunk_count = writer.chunk_count(obj)

  head = struct.pack('!4sHHI', header, v_major, v_minor, chunk_count)
  body = b''.join([writer.chunk_for_object(c) for c in obj])
  return head + body

def dump(obj, fp):
  """write a swatch to a python file object"""
  fp.write(dumps(obj))

def write(obj, filename):
  """write a swatch object to the filename specified.

  if `filename` exists, it will be overwritten.

  `obj` *must* be a list of swatches and palettes, as follows

  ```
    [ swatch* palette* ]
  ```

  the best source for how each of these are described is in the `parser`
  documentation.
  """
  with open(filename, 'wb') as f:
    dump(obj, f)

# encoding: utf-8
"""
swatch, a parser for adobe swatch exchange files
Copyright (c) 2014 Marcos A Ojeda http://generic.cx/

With notes from
http://iamacamera.org/default.aspx?id=109 and
http://www.colourlovers.com/ase.phps

All Rights Reserved
MIT Licensed, see LICENSE.TXT for details
"""
import logging
import struct
import os


def parse_chunk(fd):
  chunk_type = fd.read(2)
  while chunk_type:
    if chunk_type == b'\x00\x01':
      # a single color
      logging.debug("[swatch.parser] parse_chunk saw single color")
      o = dict_for_chunk(fd)
      yield o

    elif chunk_type == b'\xC0\x01':
      # folder/palate
      logging.debug("[swatch.parser] parse_chunk saw folder")
      o = dict_for_chunk(fd)
      o['swatches'] = [x for x in colors(fd)]
      yield o

    elif chunk_type == b'\xC0\x02':
      # this signals the end of a folder
      logging.debug("[swatch.parser] parse_chunk saw end of folder")
      assert fd.read(4) == b'\x00\x00\x00\x00'
      pass

    else:
      # the file is malformed?
      logging.debug("[swatch.parser] parse_chunk got malformed ase file")
      assert chunk_type in [
        b'\xC0\x01', b'\x00\x01', b'\xC0\x02', b'\x00\x02']
      pass

    chunk_type = fd.read(2)


def colors(fd):
  chunk_type = fd.read(2)
  while chunk_type in [b'\x00\x01', b'\x00\x02']:
    d = dict_for_chunk(fd)
    yield d
    chunk_type = fd.read(2)
  fd.seek(-2, os.SEEK_CUR)


def dict_for_chunk(fd):
  chunk_length = struct.unpack(">I", fd.read(4))[0]
  data = fd.read(chunk_length)

  title_length = (struct.unpack(">H", data[:2])[0]) * 2
  title = data[2:2 + title_length].decode("utf-16be").strip('\0')
  color_data = data[2 + title_length:]

  output = {
    'name': str(title),
    'type': 'Color Group' # default to color group
  }

  if color_data:
    fmt = {b'RGB': '!fff', b'Gray': '!f', b'CMYK': '!ffff', b'LAB': '!fff'}
    color_mode = struct.unpack("!4s", color_data[:4])[0].strip()
    color_values = list(struct.unpack(fmt[color_mode], color_data[4:-2]))

    color_types = ['Global', 'Spot', 'Process']
    swatch_type_index = struct.unpack(">h", color_data[-2:])[0]
    swatch_type = color_types[swatch_type_index]

    output.update({
      'data': {
        'mode': color_mode.decode('utf-8'),
        'values': color_values
      },
      'type': str(swatch_type)
    })

  return output

# encoding: utf-8
"""
swatch, a parser for adobe swatch exchange files
Copyright (c) 2014 Marcos A Ojeda http://generic.cx/

With notes from
http://iamacamera.org/default.aspx?id=109 and
http://www.colourlovers.com/ase.phps

All Rights Reserved
MIT Licensed, see LICENSE.TXT for details
"""
import logging
import struct
import os


def chunk_count(swatch):
  """return the number of byte-chunks in a swatch object

  this recursively walks the swatch list, returning 1 for a single color &
  returns 2 for each folder plus 1 for each color it contains
  """
  if type(swatch) is dict:
    if 'data' in swatch:
      return 1
    if 'swatches' in swatch:
      return 2 + len(swatch['swatches'])
  else:
    return sum(map(chunk_count, swatch))

def chunk_for_object(obj):
  type = obj.get('type')
  if type == 'Color Group':
    return chunk_for_folder(obj)
  if type in ['Process', 'Spot', 'Global']:
    return chunk_for_color(obj)

def chunk_for_color(obj):
  """builds up a byte-chunk for a color

  the format for this is
    b'\x00\x01' +
    Big-Endian Unsigned Int == len(bytes that follow in this block)
     • Big-Endian Unsigned Short == len(color_name)
       in practice, because utf-16 takes up 2 bytes per letter
       this will be 2 * (len(name) + 1)
       so a color named 'foo' would be 8 bytes long
     • UTF-16BE Encoded color_name terminated with '\0'
       using 'foo', this yields '\x00f\x00o\x00o\x00\x00'
     • A 4-byte char for Color mode ('RGB ', 'Gray', 'CMYK', 'LAB ')
       note the trailing spaces
     • a variable-length number of 4-byte length floats
       this depends entirely on the color mode of the color.
     • A Big-Endian short int for either a global, spot, or process color
       global == 0, spot == 1, process == 2

  the chunk has no terminating string although other sites have indicated
  that the global/spot/process short is a terminator, it's actually used
  to indicate how illustrator should deal with the color.
  """
  title = obj['name'] + '\0'
  title_length = len(title)
  chunk = struct.pack('>H', title_length)
  chunk += title.encode('utf-16be')

  mode = obj['data']['mode'].encode()
  values = obj['data']['values']
  color_type = obj['type']

  fmt = {b'RGB': '!fff', b'Gray': '!f', b'CMYK': '!ffff', b'LAB': '!fff'}
  if mode in fmt:
    padded_mode = mode.decode().ljust(4).encode()
    chunk += struct.pack('!4s', padded_mode) # the color mode
    chunk += struct.pack(fmt[mode], *values) # the color values

  color_types = ['Global', 'Spot', 'Process']
  if color_type in color_types:
    color_int = color_types.index(color_type)
    chunk += struct.pack('>h', color_int) # append swatch mode

  chunk = struct.pack('>I', len(chunk)) + chunk # prepend the chunk size
  return b'\x00\x01' + chunk # swatch color header

def chunk_for_folder(obj):
  """produce a byte-chunk for a folder of colors

  the structure is very similar to a color's data:
  • Header
    b'\xC0\x01' +
    Big Endian Unsigned Int == len(Bytes in the Header Block)
     note _only_ the header, this doesn't include the length of color data
     • Big Endian Unsigned Short == len(Folder Name + '\0')
       Note that Folder Name is assumed to be utf-16be so this
       will always be an even number
     • Folder Name + '\0', encoded UTF-16BE
  • body
    chunks for each color, see chunk_for_color
  • folder terminator
    b'\xC0\x02' +
    b'\x00\x00\x00\x00'

  Perhaps the four null bytes represent something, but i'm pretty sure
  they're just a terminating string, but there's something nice about
  how the b'\xC0\x02' matches with the folder's header
  """
  title = obj['name'] + '\0'
  title_length = len(title)
  chunk_body = struct.pack('>H', title_length) # title length
  chunk_body += title.encode('utf-16be') # title

  chunk_head = b'\xC0\x01' # folder header
  chunk_head += struct.pack('>I', len(chunk_body))
  # precede entire chunk by folder header and size of folder
  chunk = chunk_head + chunk_body

  chunk += b''.join([chunk_for_color(c) for c in obj['swatches']])

  chunk += b'\xC0\x02' # folder terminator chunk
  chunk += b'\x00\x00\x00\x00' # folder terminator
  return chunk
